//////////////////////////////////////////////////////////////////////////////
// 
//                    Copyright 2012, Cornutum Project
//                             www.cornutum.org
//
//////////////////////////////////////////////////////////////////////////////

package org.cornutum.tcases;

import org.cornutum.tcases.generator.*;
import org.cornutum.tcases.generator.io.*;
import org.cornutum.tcases.io.*;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * Generates a set of {@link TestCase test cases} from a {@link SystemInputDef system input definition}.
 *
 */
public class Tcases
  {
  /**
   * Represents a set of generator options.
   */
  public static class Options
    {
    public enum TransformType { HTML, JUNIT, CUSTOM };

    /**
     * Creates a new Options object.
     */
    public Options()
      {
      setExtended( true);
      setWorkingDir( null);
      }


    /**
     * Changes the output directory for generated test definitions.
     */
    public void setOutDir( File outDir)
      {
      outDir_ = outDir;
      }

    /**
     * Returns the output directory for generated test definitions.
     */
    public File getOutDir()
      {
      return outDir_;
      }

    /**
     * Changes the output file for generated test definitions.
     */
    public void setOutFile( File outFile)
      {
      outFile_ = outFile;
      }

    /**
     * Returns the output file for generated test definitions.
     */
    public File getOutFile()
      {
      return outFile_;
      }

    /**
     * Changes the output file for generated test definitions.
     */
    public void setTestDef( File testDef)
      {
      testDef_ = testDef;
      }

    /**
     * Returns the output file for generated test definitions.
     */
    public File getTestDef()
      {
      return testDef_;
      }

    /**
     * Changes the generator definition file.
     */
    public void setGenDef( File genDef)
      {
      genDef_ = genDef;
      }

    /**
     * Returns the generator definition file.
     */
    public File getGenDef()
      {
      return genDef_;
      }

    /**
     * Changes the transform file.
     */
    public void setTransformDef( File transformDef)
      {
      transformDef_ = transformDef;
      }

    /**
     * Returns the transform file.
     */
    public File getTransformDef()
      {
      return transformDef_;
      }

    /**
     * Changes the output transform type.
     */
    public void setTransformType( TransformType transformType)
      {
      transformType_ = transformType;
      }

    /**
     * Returns the output transform type.
     */
    public TransformType getTransformType()
      {
      return transformType_;
      }

    /**
     * Changes the transform parameter bindings.
     */
    public void setTransformParams( Map<String,Object> params)
      {
      transformParams_ = params;
      }

    /**
     * Returns the transform parameter bindings.
     */
    public Map<String,Object> getTransformParams()
      {
      return transformParams_;
      }

    /**
     * Changes the input definition file
     */
    public void setInputDef( File inputDef)
      {
      inputDef_ = inputDef;
      }

    /**
     * Returns the input definition file
     */
    public File getInputDef()
      {
      return inputDef_;
      }

    /**
     * Changes if new test definitions are generated by extending the
     * previous {@link #getTestDef test definitions}.
     */
    public void setExtended( boolean extended)
      {
      extended_ = extended;
      }

    /**
     * Returns if new test definitions are generated by extending the
     * previous {@link #getTestDef test definitions}.
     */
    public boolean isExtended()
      {
      return extended_;
      }

    /**
     * Changes the random seed used by generators.
     */
    public void setRandomSeed( Long seed)
      {
      seed_ = seed;
      }

    /**
     * Returns the random seed used by generators.
     */
    public Long getRandomSeed()
      {
      if( seed_ == null && isNewSeed())
        {
        setRandomSeed( (long) (Math.random() * Long.MAX_VALUE));
        }

      return seed_;
      }

    /**
     * Changes if choosing a new random seed used by generators.
     */
    public void setNewSeed( boolean newSeed)
      {
      newSeed_ = newSeed;
      }

    /**
     * Returns if choosing a new random seed used by generators.
     */
    public boolean isNewSeed()
      {
      return newSeed_;
      }

    /**
     * Changes the default tuple size used by generators.
     */
    public void setDefaultTupleSize( Integer tupleSize)
      {
      defaultTupleSize_ = tupleSize;
      }

    /**
     * Returns the default tuple size used by generators.
     */
    public Integer getDefaultTupleSize()
      {
      return defaultTupleSize_;
      }

    /**
     * Changes the current working directory used to complete relative path names.
     */
    public void setWorkingDir( File workingDir)
      {
      workingDir_ =
        workingDir == null
        ? new File( ".")
        : workingDir;
      }

    /**
     * Returns the current working directory used to complete relative path names.
     */
    public File getWorkingDir()
      {
      return workingDir_;
      }

    /**
     * Changes if the current version should be shown.
     */
    public void setShowVersion( boolean showVersion)
      {
      showVersion_ = showVersion;
      }

    /**
     * Returns if the current version should be shown.
     */
    public boolean showVersion()
      {
      return showVersion_;
      }

    private File inputDef_;
    private File outDir_;
    private File outFile_;
    private File testDef_;
    private File genDef_;
    private File transformDef_;
    private Map<String,Object> transformParams_ = new HashMap<String,Object>();
    private TransformType transformType_;
    private boolean extended_;
    private Long seed_;
    private boolean newSeed_;
    private Integer defaultTupleSize_;
    private File workingDir_;
    private boolean showVersion_;
    }

  /**
   * Creates a new Tcases object.
   */
  public Tcases()
    {
    }

  /**
   * Returns test case definitions for the given system input definition, using the given generator set and
   * base test definitions. If <CODE>genDef</CODE> is null, the default generator is used.
   * If <CODE>baseDef</CODE> is null, no base test definitions are used.
   */
  public static SystemTestDef getTests( SystemInputDef inputDef, IGeneratorSet genDef, SystemTestDef baseDef, Options options)
    {
    if( genDef == null)
      {
      genDef = GeneratorSet.basicGenerator();
      }

    Long seed = options==null? null : options.getRandomSeed();
    Integer defaultTupleSize = options==null? null : options.getDefaultTupleSize();

    SystemTestDef testDef = new SystemTestDef( inputDef.getName());
    for( Iterator<FunctionInputDef> functionDefs = inputDef.getFunctionInputDefs(); functionDefs.hasNext();)
      {
      FunctionInputDef functionDef = functionDefs.next();
      FunctionTestDef functionBase = baseDef==null? null : baseDef.getFunctionTestDef( functionDef.getName());
      ITestCaseGenerator functionGen = genDef.getGenerator( functionDef.getName());
      if( functionGen == null)
        {
        throw new RuntimeException( "No generator for function=" + functionDef.getName());
        }

      // If applicable, apply specified generator options.
      if( seed != null)
        {
        functionGen.setRandomSeed( seed);
        }
      if( defaultTupleSize != null && functionGen instanceof TupleGenerator)
        {
        ((TupleGenerator) functionGen).setDefaultTupleSize( defaultTupleSize);
        }
      
      testDef.addFunctionTestDef( functionGen.getTests( functionDef, functionBase));
      }

    annotateTests( inputDef, testDef);
    
    return testDef;
    }

  /**
   * Returns test case definitions for the given system input definition, using the given generator set and
   * base test definitions. If <CODE>genDef</CODE> is null, the default generator is used.
   * If <CODE>baseDef</CODE> is null, no base test definitions are used.
   */
  public static SystemTestDef getTests( SystemInputDef inputDef, IGeneratorSet genDef, SystemTestDef baseDef)
    {
    return getTests( inputDef, genDef, baseDef, null);
    }

  /**
   * Returns test case definitions for the given system input definition, using the given generator set and
   * base test definitions. If <CODE>genDef</CODE> is null, the default generator is used.
   * If <CODE>baseDef</CODE> is null, no base test definitions are used.
   */
  public static SystemTestDef getTests( InputStream inputDefStream, InputStream genDefStream, InputStream baseDefStream)
    {
    try
      {
      return
        getTests
        ( new SystemInputDocReader( inputDefStream).getSystemInputDef(),
          genDefStream==null? null : new GeneratorSetDocReader( genDefStream).getGeneratorSet(),
          baseDefStream==null? null : new SystemTestDocReader( baseDefStream).getSystemTestDef());
      }
    catch( Exception e)
      {
      throw new RuntimeException( "Can't get test definitions", e);
      }
    }

  /**
   * Returns new test case definitions for the given system input definition, using the default generator.
   */
  public static SystemTestDef getTests( InputStream inputDefStream)
    {
    return getTests( inputDefStream, null, null);
    }

  /**
   * Updates the given test definitions by adding all applicable annotations from the given input definition.
   */
  public static void annotateTests( SystemInputDef inputDef, SystemTestDef testDef)
    {
    // Add system annotations
    testDef.addAnnotations( inputDef);

    for( Iterator<FunctionTestDef> functionTestDefs = testDef.getFunctionTestDefs(); functionTestDefs.hasNext();)
      {
      // Add function annotations
      FunctionTestDef functionTestDef = functionTestDefs.next();
      FunctionInputDef functionInputDef = inputDef.getFunctionInputDef( functionTestDef.getName());
      functionTestDef.addAnnotations( functionInputDef);
      functionTestDef.addAnnotations( inputDef);
      
      // Add test case annotations.
      for( Iterator<TestCase> testCases = functionTestDef.getTestCases(); testCases.hasNext(); )
        {
        TestCase testCase = testCases.next();
        testCase.addAnnotations( functionInputDef);
        testCase.addAnnotations( inputDef);

        // Add variable binding annotations.
        for( Iterator<VarBinding> varBindings = testCase.getVarBindings(); varBindings.hasNext(); )
          {
          VarBinding binding = varBindings.next();
          VarDef varDef = functionInputDef.findVarDefPath( binding.getVar());
          String value = binding.getValue();

          // Add value annotations...
          if( !value.equals( VarValueDef.NA.getName()))
            {
            VarValueDef valueDef = varDef.getValue( value);
            binding.addAnnotations( valueDef);
            }

          // ...and any other annotations for this variable...
          binding.addAnnotations( varDef);

          // ...and any other annotations for variable sets that contain this variable.
          for( IVarDef ancestor = varDef.getParent(); ancestor != null; ancestor = ancestor.getParent())
            {
            if( ancestor instanceof Annotated)
              {
              binding.addAnnotations( (Annotated) ancestor);
              }
            }
          }
        }
      }
    }

  /**
   * Writes an XML document describing given test case definitions to the given output stream.
   */
  @SuppressWarnings("resource")
  public static void writeTests( SystemTestDef testDef, OutputStream outputStream)
    {
    try
      {
      SystemTestDocWriter writer = new SystemTestDocWriter( outputStream);
      writer.write( testDef);
      writer.flush();
      }
    catch( Exception e)
      {
      throw new RuntimeException( "Can't write test definitions", e);
      }
    }
  }
